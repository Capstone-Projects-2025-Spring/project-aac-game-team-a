"use strict";(self.webpackChunkcreate_project_docs=self.webpackChunkcreate_project_docs||[]).push([[3791],{10659:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"system-architecture/design","title":"design","description":"Component Descriptions","source":"@site/docs/system-architecture/design.md","sourceDirName":"system-architecture","slug":"/system-architecture/design","permalink":"/project-aac-game-team-a/docs/system-architecture/design","draft":false,"unlisted":false,"editUrl":"https://github.com/Capstone-Projects-2025-Spring/project-aac-game-team-a/tree/main/documentation/docs/system-architecture/design.md","tags":[],"version":"current","lastUpdatedBy":"kenfonseca","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Version Control","permalink":"/project-aac-game-team-a/docs/system-architecture/version-control"},"next":{"title":"API Specification","permalink":"/project-aac-game-team-a/docs/category/api-specification"}}');var t=r(74848),a=r(28453);const i={},o=void 0,d={},l=[{value:"Component Descriptions",id:"component-descriptions",level:2},{value:"Frontend (Client-Side) Vue/Socket.io-Client/Pinia:",id:"frontend-client-side-vuesocketio-clientpinia",level:3},{value:"1. Main",id:"1-main",level:4},{value:"2. Pinia",id:"2-pinia",level:4},{value:"3. App",id:"3-app",level:4},{value:"4. defineStore",id:"4-definestore",level:4},{value:"5. RouterLink",id:"5-routerlink",level:4},{value:"6. RouterView",id:"6-routerview",level:4},{value:"7. SettingState",id:"7-settingstate",level:4},{value:"8. GameState",id:"8-gamestate",level:4},{value:"9. SettingsOverlay",id:"9-settingsoverlay",level:4},{value:"10. Router",id:"10-router",level:4},{value:"11. HomeView",id:"11-homeview",level:4},{value:"12. GameView",id:"12-gameview",level:4},{value:"13. aacBoard",id:"13-aacboard",level:4},{value:"14. DrawingBoard",id:"14-drawingboard",level:4},{value:"15. WaitingRoom",id:"15-waitingroom",level:4},{value:"16. GuessBoard",id:"16-guessboard",level:4},{value:"17. EndGameScreen",id:"17-endgamescreen",level:4},{value:"18. HostLobbyView",id:"18-hostlobbyview",level:4},{value:"19. JoinLobbyView",id:"19-joinlobbyview",level:4},{value:"20. HomeViewContent",id:"20-homeviewcontent",level:4},{value:"21. SpeechSynthesis",id:"21-speechsynthesis",level:4},{value:"Backend (Server-Side) Socket.io/Express/Node:",id:"backend-server-side-socketioexpressnode",level:3},{value:"22. Server",id:"22-server",level:4},{value:"23. SocketServerHandler",id:"23-socketserverhandler",level:4},{value:"24. SocketServer",id:"24-socketserver",level:4},{value:"25. ExpressApp",id:"25-expressapp",level:4},{value:"26. HttpServer",id:"26-httpserver",level:4},{value:"27. GameData",id:"27-gamedata",level:4},{value:"Class Diagram",id:"class-diagram",level:2},{value:"Sequence Diagrams",id:"sequence-diagrams",level:2},{value:"Algorithms",id:"algorithms",level:2},{value:"1. Player Selection (Random Drawer)",id:"1-player-selection-random-drawer",level:3},{value:"2. Word Selection (Random Prompt Assignment)",id:"2-word-selection-random-prompt-assignment",level:3},{value:"3. Guess Matching Algorithm",id:"3-guess-matching-algorithm",level:3},{value:"4. Score Calculation",id:"4-score-calculation",level:3},{value:"Collection Schemas",id:"collection-schemas",level:3},{value:"Collection Schemas",id:"collection-schemas-1",level:4}];function c(e){const n={br:"br",code:"code",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"component-descriptions",children:"Component Descriptions"}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"frontend-client-side-vuesocketio-clientpinia",children:"Frontend (Client-Side) Vue/Socket.io-Client/Pinia:"}),"\n",(0,t.jsx)(n.h4,{id:"1-main",children:"1. Main"}),"\n",(0,t.jsx)(n.p,{children:"The Main class is responsible for initializing and setting up the core functionality of the application. It creates the App instance, integrates the Pinia state management, and sets up the Router to handle routing between views. It also mounts the application to the DOM."}),"\n",(0,t.jsx)(n.h4,{id:"2-pinia",children:"2. Pinia"}),"\n",(0,t.jsx)(n.p,{children:"Pinia is a state management system used to store and manage the application's state. It works similarly to Vuex but is a more modern and simplified alternative for state management in Vue.js applications."}),"\n",(0,t.jsx)(n.h4,{id:"3-app",children:"3. App"}),"\n",(0,t.jsx)(n.p,{children:"The App class serves as the root of the application. It contains important child components such as RouterView, which handles the routing of views, SettingState, which holds the application's settings, and SettingsOverlay, which provides a UI for overlay settings adjustments."}),"\n",(0,t.jsx)(n.h4,{id:"4-definestore",children:"4. defineStore"}),"\n",(0,t.jsx)(n.p,{children:"defineStore is used for defining stores in the Pinia state management system. A store holds the state and actions used to manage it across different components in the application."}),"\n",(0,t.jsx)(n.h4,{id:"5-routerlink",children:"5. RouterLink"}),"\n",(0,t.jsx)(n.p,{children:"RouterLink is a component used to create links between different routes in the application. It allows navigation from one view to another when clicked."}),"\n",(0,t.jsx)(n.h4,{id:"6-routerview",children:"6. RouterView"}),"\n",(0,t.jsx)(n.p,{children:"RouterView is a placeholder component that renders the view corresponding to the current route. It is part of the Vue Router, which handles navigation between different components/views in the app."}),"\n",(0,t.jsx)(n.h4,{id:"7-settingstate",children:"7. SettingState"}),"\n",(0,t.jsx)(n.p,{children:"The SettingState class holds various user settings such as whether text-to-speech (TTS) is enabled, the opacity of the background, and the path to TTS images. It also includes methods to modify these settings, such as adjusting TTS volume or background opacity, and toggling the settings overlay."}),"\n",(0,t.jsx)(n.h4,{id:"8-gamestate",children:"8. GameState"}),"\n",(0,t.jsx)(n.p,{children:"GameState manages the state of the game, such as player data (e.g., user, avatar, room code), game rules (e.g., rounds, max players), and the game\u2019s progression (e.g., host status, game state)."}),"\n",(0,t.jsx)(n.h4,{id:"9-settingsoverlay",children:"9. SettingsOverlay"}),"\n",(0,t.jsx)(n.p,{children:"The SettingsOverlay class provides a UI overlay for adjusting game settings like TTS. It allows the user to change settings and control the volume and opacity of TTS. It also includes functionality for text-to-speech conversion."}),"\n",(0,t.jsx)(n.h4,{id:"10-router",children:"10. Router"}),"\n",(0,t.jsx)(n.p,{children:"Router handles the routing between different views in the application. It defines routes to the HomeView, GameView, HostLobbyView, and JoinLobbyView components, each corresponding to different parts of the app."}),"\n",(0,t.jsx)(n.h4,{id:"11-homeview",children:"11. HomeView"}),"\n",(0,t.jsx)(n.p,{children:"HomeView is the main entry point or home page of the application. It displays initial content and provides navigation to other views."}),"\n",(0,t.jsx)(n.h4,{id:"12-gameview",children:"12. GameView"}),"\n",(0,t.jsx)(n.p,{children:"GameView is the main game interface, where players interact with each other. It includes methods for triggering popups, handling game mechanics (e.g., drawing, guessing), and communicating with the server."}),"\n",(0,t.jsx)(n.h4,{id:"13-aacboard",children:"13. aacBoard"}),"\n",(0,t.jsx)(n.p,{children:"The aacBoard is a communication tool for users with special needs. It allows users to select items and categories, and it provides a text-to-speech function to speak the selected item."}),"\n",(0,t.jsx)(n.h4,{id:"14-drawingboard",children:"14. DrawingBoard"}),"\n",(0,t.jsx)(n.p,{children:"The DrawingBoard provides the functionality for users to draw on a canvas. It includes methods for starting, drawing, and stopping the drawing process, as well as undoing and clearing the canvas."}),"\n",(0,t.jsx)(n.h4,{id:"15-waitingroom",children:"15. WaitingRoom"}),"\n",(0,t.jsx)(n.p,{children:"WaitingRoom is the lobby area before the game starts. It provides the functionality for players to wait, view the game\u2019s shape images, and either start or leave the game."}),"\n",(0,t.jsx)(n.h4,{id:"16-guessboard",children:"16. GuessBoard"}),"\n",(0,t.jsx)(n.p,{children:"The GuessBoard is the section where players can make guesses during the game. It manages the current round, time, and player data, and communicates with the game state."}),"\n",(0,t.jsx)(n.h4,{id:"17-endgamescreen",children:"17. EndGameScreen"}),"\n",(0,t.jsx)(n.p,{children:"EndGameScreen shows the final results after the game ends. It provides options to play again or leave the game and checks if a player has achieved a high score."}),"\n",(0,t.jsx)(n.h4,{id:"18-hostlobbyview",children:"18. HostLobbyView"}),"\n",(0,t.jsx)(n.p,{children:"HostLobbyView allows the host to manage game settings such as the number of players, round count, and avatar selection. The host can also start the game from here."}),"\n",(0,t.jsx)(n.h4,{id:"19-joinlobbyview",children:"19. JoinLobbyView"}),"\n",(0,t.jsx)(n.p,{children:"JoinLobbyView is for players joining an existing lobby. It allows players to select their avatar and shape, and it provides the option to join the game."}),"\n",(0,t.jsx)(n.h4,{id:"20-homeviewcontent",children:"20. HomeViewContent"}),"\n",(0,t.jsx)(n.p,{children:"HomeViewContent contains the content displayed on the home page. It handles user interaction, such as clicking on text to navigate to different routes."}),"\n",(0,t.jsx)(n.h4,{id:"21-speechsynthesis",children:"21. SpeechSynthesis"}),"\n",(0,t.jsx)(n.p,{children:"SpeechSynthesis is used to convert text to speech, providing accessibility features like TTS for the application."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"backend-server-side-socketioexpressnode",children:"Backend (Server-Side) Socket.io/Express/Node:"}),"\n",(0,t.jsx)(n.h4,{id:"22-server",children:"22. Server"}),"\n",(0,t.jsx)(n.p,{children:"The Server class manages the server initialization, starting the server, and handling server requests. It is responsible for hosting the game."}),"\n",(0,t.jsx)(n.h4,{id:"23-socketserverhandler",children:"23. SocketServerHandler"}),"\n",(0,t.jsx)(n.p,{children:"SocketServerHandler listens for socket events and manages communication between the server and clients. It handles setting up the server, client connection, and managing game data over WebSockets."}),"\n",(0,t.jsx)(n.h4,{id:"24-socketserver",children:"24. SocketServer"}),"\n",(0,t.jsx)(n.p,{children:"SocketServer is responsible for managing the socket server instance and handling communication with clients."}),"\n",(0,t.jsx)(n.h4,{id:"25-expressapp",children:"25. ExpressApp"}),"\n",(0,t.jsx)(n.p,{children:"ExpressApp is responsible for setting up the Express application, typically used for building REST APIs in Node.js."}),"\n",(0,t.jsx)(n.h4,{id:"26-httpserver",children:"26. HttpServer"}),"\n",(0,t.jsx)(n.p,{children:"HttpServer is used for handling HTTP requests, typically through the Express application, to interact with clients."}),"\n",(0,t.jsx)(n.h4,{id:"27-gamedata",children:"27. GameData"}),"\n",(0,t.jsx)(n.p,{children:"GameData manages the data specific to the game session, such as player data, game rounds, prompts, and timer. It includes methods for updating the game state, starting new rounds, and checking if all guesses are correct."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"class-diagram",children:"Class Diagram"}),"\n",(0,t.jsx)(n.mermaid,{value:"classDiagram\r\n   class Main {\r\n       +createApp(App)\r\n       +use(Pinia)\r\n       +use(Router)\r\n       +mount()\r\n   }\r\n   class Pinia {\r\n   }\r\n   class App {\r\n       +RouterView\r\n       +SettingState\r\n       +SettingsOverlay\r\n   }\r\n   class defineStore {\r\n   }\r\n   class RouterLink {\r\n   }\r\n   class RouterView {\r\n   }\r\n   class SettingState {\r\n       -showSettings: boolean\r\n       -enableTTS: boolean\r\n       -pathToTTSimg: string\r\n       -backgroundOpacity: number\r\n\r\n\r\n       +setModeTTS(enableTTS: boolean) void\r\n       +setVolumeTTS(newVolume: number) void\r\n       +setBackgroundOpacity(value: number) void\r\n       +toggleSettings() void\r\n   }\r\n   class GameState{\r\n       +setGameState(user: string, avatar: string, code: number, isHost: boolean, maxPlayers: number, rounds: number, isHostPlaying: boolean)\r\n   }\r\n   class SettingsOverlay {\r\n       +toggleTTS() void\r\n       +updateVolume(e) void\r\n       +updateOpacity(e) void\r\n       +close() void\r\n   }\r\n   class Router {\r\n       +HomeView\r\n       +GameView\r\n       +HostLobbyView\r\n       +JoinLobbyView\r\n   }\r\n   class SpeechHelper{\r\n      +speakNow(textToSpeak: string, settinsState: boolean) void\r\n   }\r\n   class HomeView {\r\n       +HomeViewContent\r\n   }\r\n   class GameView {\r\n       +triggerAllGuessedCorrectPopup() void\r\n       +triggerTimeRanOutPopup() void\r\n       +speakRoomCode() void\r\n       +getShapeImage(digit: number) string\r\n       +getShapeLabel(digit: number) string\r\n       +serverConnect() void\r\n       +serverDisconnect() void\r\n       +handleItemSelected(item: string, imagePath: string) void\r\n       +sendDrawDataInit(x: number, y: number, draw_color: string, draw_width: number) void\r\n       +sendDrawData(x: number, y: number) void\r\n       +sendDrawDataEnd() void\r\n       +sendDrawDataClear() void\r\n       +sendDrawDataUndo() void\r\n       +sendTimerStart(length: number) void\r\n       +startGame() void\r\n       +playAgain() void\r\n       +leaveLobby() void\r\n       -roomCodeArr: number\r\n       -currentUserMessage: object\r\n       -showTimeRanOutPopup: boolean\r\n       -showAllGuessedCorrectPopup: boolean\r\n       -playerScore: number\r\n       -settingState: boolean\r\n       -selectedImagePath: string\r\n       -currentUser: string\r\n       -currentUserAvatar: string\r\n       -currentUserMessage: string\r\n       -currentDrawer: string\r\n       -isGuessCorrect: boolean\r\n       -messageBoard: object[]\r\n       -mappedPlayerData: Map\r\n       -isDrawer: boolean\r\n       -isHost: boolean\r\n       -isHostPlaying: boolean\r\n       -promptWord: string\r\n       -promptImgPath: string\r\n       -context: canvas\r\n       -numRounds: number\r\n       -currentRound: number\r\n       -maxPlayers: number\r\n       -players: string[]\r\n       -roundTimer: number\r\n       -roomCodeArr: number[]\r\n       -roomCodeStr: string\r\n       -gameStarted: boolean\r\n       -gameEnded: boolean\r\n       -AACboardDisabled: boolean\r\n       -AACboardDisabledDuration: number\r\n       -AACboardDisableTimer: number\r\n       -AACButtons:\r\n       -roomCodeShapes:\r\n   }\r\n   class SocketClientHandler{\r\n      +connectSocketServer(socketServer: string, testServer: string, inProduction: boolean, gameData: object) Socket\r\n      +initSocketConnection(socketServer: string, testServer: string, inProduction: boolean) void\r\n      +reateLobby(socket: object, gameData: object) void\r\n      +initSocketListeners(socket: object, gameData: object) void\r\n   }\r\n   class aacBoard {\r\n       +selectItem(item: string) void\r\n       +setCurrentCategory(category: string|null) void\r\n       +getCategoryImage(category: string) string\r\n       +getItemImage(category: string, item: string) string\r\n\r\n\r\n       -currentCategory: string\r\n       -categories: object\r\n       -categoryList: string[]\r\n       -settingsState: SettingState\r\n       -emit: function\r\n       -props: [ disabled: boolean, timeDisabled: number ]\r\n   }\r\n   class DrawingBoard {\r\n       +clear_canvas() void\r\n       +undo_action() void\r\n       +saveState() void\r\n       +start(event: Event) void\r\n       +draw(event: Event) void\r\n       +stop(event: Event) void\r\n       +calculateDrawCoords(event: Event) ( x: number, y: number )\r\n      \r\n       -canvasRef: HTMLElement|null\r\n       -context: CanvasRenderingContext2D|null\r\n       -undoHistory: any[]\r\n       -draw_color: string\r\n       -is_drawing: boolean\r\n       -draw_width: number\r\n       -start_background_color: string\r\n       -props: [ isDrawer: boolean ]\r\n   }\r\n   class WaitingRoom {\r\n       +speakRoomCode() void\r\n       +getShapeImg(digit: number) string\r\n       +showNotEnoughPlayersAlert() void\r\n       +startGame() void\r\n       +leaveLobby() void\r\n\r\n\r\n       -props: [ roomCode: string[], maxPlayers: number, players: string[], numRounds: number, isHost: boolean, isHostPlaying: boolean ]\r\n       -settingsState: object\r\n       -shapes: [ value: number, imgSrc: string, shape: string ]\r\n   }\r\n\r\n\r\n   class GuessBoard {\r\n       -props: [\r\n           playerDataMap: Map<String, [ score: number, currentGuess: string, currentGuessImagePath: string ]>,\r\n           time: number,\r\n           currentRound: number,\r\n           totalRounds: number,\r\n           roomCodeArr: number[],\r\n           getShapeImage: function,\r\n           getShapeLabel: function,\r\n           speakRoomCode: function,\r\n           currentDrawer: string\r\n       ]\r\n   }\r\n\r\n\r\n   class EndGameScreen {\r\n       +playAgain() void\r\n       +leaveLobby() void\r\n       +hasHighscore(score: number) bool\r\n       -props: [\r\n           isHost: boolean,\r\n           playerDataMap: Map<String, [ score: number ]>\r\n       ]\r\n   }\r\n\r\n\r\n   class HostLobbyView {\r\n       +validatePlayerCount() void\r\n       +validateRoundCount() void\r\n       +toggleAvatars(show: boolean) void\r\n       +selectAvatar(button) void\r\n       +launchRoom() void\r\n       -userGameState: GameState\r\n       -settingsState: SettingState\r\n       -maxPlayers: number\r\n       -rounds: number\r\n       -randomCodeDigits: number[]\r\n       -currentUser: string\r\n       -currentUserAvatar: string\r\n       -showAvatars: boolean\r\n       -isHostPlaying: boolean\r\n       -randomCodeString: string\r\n       -avatarButtons: string\r\n   }\r\n   class JoinLobbyView {\r\n       +showNoAvatarSelectedAlert() void\r\n       +selectShape(shape) void\r\n       +undoShape() void\r\n       +clearShapes() void\r\n       +selectAvatar(button) void\r\n       +joinLobby() void\r\n       -userGameState: GameState\r\n       -settingsState: SettingState\r\n       -selectedShapes: string[]|null\r\n       -shapes: string[]\r\n       -roomCodeArr: number[]\r\n       -currentUser: string\r\n       -currentUserAvatar: string\r\n       -avatarButtons: string[]\r\n   }\r\n   class HomeViewContent {\r\n       +handleClick(text: string, route: string) void\r\n   }\r\n   class SpeechSynthesis {\r\n   }\r\n\r\n\r\n   Main --\x3e App : uses\r\n   Main --\x3e Router : uses\r\n   Main --\x3e Pinia : uses\r\n\r\n   App --\x3e RouterView : uses\r\n   App --\x3e SettingState : uses\r\n   App --\x3e SettingsOverlay : uses\r\n\r\n   SettingsOverlay --\x3e SettingState : uses\r\n   SettingsOverlay --\x3e SpeechHelper: uses\r\n\r\n   SettingState --|> defineStore : based on\r\n   GameState --|> defineState: based on\r\n\r\n   RouterView --\x3e Router : depends on\r\n   RouterLink --\x3e RouterView : depends on\r\n\r\n   Router --\x3e HomeView : route to\r\n   Router --\x3e GameView : route to\r\n   Router --\x3e HostLobbyView : route to\r\n   Router --\x3e JoinLobbyView : route to\r\n\r\n   HomeView --\x3e HomeViewContent : uses\r\n\r\n   HomeViewContent --\x3e SettingState : uses\r\n   HomeViewContent --\x3e Router : navigates with\r\n   HomeViewContent --\x3e SpeechSynthesis : uses\r\n   HomwViewContent --\x3e SpeechHelper: uses\r\n\r\n   HostLobbyView --\x3e GameState : uses\r\n   HostLobbyView --\x3e SettingState : uses\r\n   HostLobbyView --\x3e SpeechSynthesis : uses\r\n   HostLobbyView --\x3e RouterLink : navigates with\r\n   HostLobbyView --\x3e SpeechHelper: uses\r\n\r\n   JoinLobbyView --\x3e GameState : uses\r\n   JoinLobbyView --\x3e SettingState : uses\r\n   JoinLobbyView --\x3e SpeechSynthesis : uses\r\n   JoinLobbyView --\x3e RouterLink : navigates with\r\n   JoinLobbyView --\x3e SpeechHelper: uses\r\n\r\n   GameView --\x3e aacBoard : uses\r\n   GameView --\x3e DrawingBoard : uses\r\n   GameView --\x3e WaitingRoom : uses\r\n   GameView --\x3e GuessBoard : uses\r\n   GameView --\x3e EndGameScreen : uses\r\n   GameView --\x3e GameState : uses\r\n   GameView --\x3e SettingState : uses\r\n   GameView --\x3e SocketClientHandler : uses\r\n   GameView --\x3e SpeechHelper: uses\r\n\r\n   aacBoard --\x3e SettingState : uses\r\n   aacBoard --\x3e SpeechHelper: uses\r\n   \r\n   DrawingBoard --\x3e SettingState : uses\r\n   DrawingBoard --\x3e SpeechHelper: uses\r\n\r\n   WaitingRoom --\x3e SettingState : uses\r\n   WaitingRoom --\x3e RouterLink : uses\r\n   WaitingRoom --\x3e SpeechHelper: uses\r\n\r\n   GuessBoard --\x3e SettingState : uses\r\n   GuessBoard --\x3e SpeechHelper: uses\r\n\r\n   EndGameScreen --\x3e SettingState : uses\r\n   EndGameScreen --\x3e Router : uses\r\n   EndGameScreen --\x3e SpeechHelper: uses\r\n\r\n\r\nclass Server {\r\n       +initialize() void\r\n       +startServer() void\r\n   }\r\n\r\n\r\n   class SocketServerHandler {\r\n       +initializeServerListeners(io: SocketIO.Server, socket: SocketIO.Socket, mappedGameData: Map) void\r\n       +startServer(server: http.Server, port: number) void\r\n   }\r\n\r\n\r\n   class SocketServer {\r\n   }\r\n\r\n\r\n   class ExpressApp {\r\n   }\r\n\r\n\r\n   class HttpServer {\r\n   }\r\n\r\n\r\n   class SocketServerHandler {\r\n       +createServerInstance(httpServer: http.Server) SocketIO.Server\r\n       +startServer(httpServer: http.Server, port: number) void\r\n       +initializeServerListeners(server: SocketIO.Server, client: SocketIO.Socket, gameDataMap: Map) void\r\n   }\r\n\r\n\r\n    class GameData {\r\n       +numberRounds\r\n       +currentRound\r\n       +maxPlayers\r\n       +players\r\n       +prompt\r\n       +drawer\r\n       +timerID\r\n       +timerValue\r\n       +playerData\r\n       +startNewRound(server, room, gameDataMap)\r\n       +getPromptObject()\r\n       +getPath(promptObject)\r\n       +clearGuesses(server, room)\r\n       +allGuessesCorrect()\r\n       +updateTimer(server, room, gameDataMap)\r\n   }\r\n\r\n   ExpressApp --\x3e Server : uses\r\n   HttpServer --\x3e Server : uses\r\n   SocketServerHandler --\x3e Server : listens to socket events\r\n   SocketServer --\x3e SocketServerHandler : manages server instance\r\n   SocketServerHandler --\x3e MappedGameData : manages game state\r\n   SocketServerHandler --\x3e GameData : uses\r\n   SocketServerHandler --\x3e SocketIO.Server : creates\r\n   SocketServerHandler --\x3e SocketIO.Socket : listens to\r\n   SocketServerHandler --\x3e gameDataMap : uses\r\n\r\n\r\n   GameView --\x3e Server : sends requests to\r\n   Server --\x3e GameView : sends responses or emits events"}),"\n",(0,t.jsx)(n.h2,{id:"sequence-diagrams",children:"Sequence Diagrams"}),"\n",(0,t.jsxs)(n.p,{children:["#1 ",(0,t.jsx)(n.strong,{children:"Host hosts game"})]}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\r\n\r\nactor host\r\nparticipant landingPage.js\r\nparticipant backend.js\r\n\r\nhost ->> landingPage.js: clicks host game button\r\nlandingPage.js -) backend.js: hostGame websocket message\r\nbackend.js --\x3e> landingPage.js: you are the host (websocket)\r\nlandingPage.js ->> lobby.js: navigates to\r\nlobby.js ->> host: host sees lobby page"}),"\n",(0,t.jsx)(n.p,{children:"Sequence Diagram 1"}),"\n",(0,t.jsx)(n.p,{children:'The player setting up the game navigates to the website. Upon arrival, they see a large "Host Game" Button. This triggers the creation of a lobby with a room code that the host can share to the other players.'}),"\n",(0,t.jsx)(n.p,{children:'The host navigates to the website, and they click the large "host game" button. This triggers landingPage.js to send a message to the backend notifying that the host has hosted a game. This returns a websocket message back to the landingPage that relays stores a isHost boolean on the host\'s LandingPage. Then the landingPage immediately navigates to lobby.js, bringing with it information including the isHost boolean. Then thes host can see the lobby page with the necessary host componenets.'}),"\n",(0,t.jsx)(n.p,{children:'Triggering Event:\r\nHost navigates to the game website and clicks a button "Host Game".'}),"\n",(0,t.jsxs)(n.p,{children:["#2 ",(0,t.jsx)(n.strong,{children:"Host gets room code"})]}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\r\n\r\nactor host\r\n\r\nlandingPage.js ->> backend.js: hostGame websocket message\r\n\r\nbackend.js ->> backend.js: generates room code\r\nlandingPage.js ->> lobby.js: navigates to\r\nlobby.js ->> backend.js: request room code (websocket)\r\nactivate lobby.js\r\nbackend.js --\x3e> lobby.js: return room code (websocket)\r\ndeactivate lobby.js\r\nlobby.js ->> host: display room code\r\n"}),"\n",(0,t.jsx)(n.p,{children:"Sequence Diagram 2"}),"\n",(0,t.jsx)(n.p,{children:"The host is presented with a short room code that they will tell the players so they can enter it and join."}),"\n",(0,t.jsx)(n.p,{children:'Triggering Event: The host has created a lobby by pressing "Host Game".'}),"\n",(0,t.jsxs)(n.p,{children:["#3 ",(0,t.jsx)(n.strong,{children:"Host presses start game button"})]}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\r\nactor player\r\n\r\nactor host\r\n\r\nhost ->> lobby.js: presses start game\r\nactivate lobby.js\r\nlobby.js ->> backend.js: start game (websocket)\r\nbackend.js ->> lobby.js: to all fontends: start game (websocket)\r\nlobby.js ->> drawing.js: navigate to\r\n\r\n\r\n"}),"\n",(0,t.jsx)(n.p,{children:"Sequence Diagram 3: one diagram showing the possibility of drawing."}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\r\nactor player\r\n\r\nactor host\r\n\r\nhost ->> lobby.js: presses start game\r\nactivate lobby.js\r\nlobby.js ->> backend.js: start game (websocket)\r\nbackend.js ->> lobby.js: to all frontends: start game (websocket)\r\nlobby.js ->> guessing.js: navigate to"}),"\n",(0,t.jsx)(n.p,{children:"Sequence Diagram 4: alternative diagram showing the possibility of guessing."}),"\n",(0,t.jsx)(n.p,{children:'Once everyone has joined, the host will choose to press the "start game button". This will send a websocket message to the backend, which will be echoed back to all frontends. Then all frontends will navigate to either drawing.js or guessing.js depending on their role for the first round.'}),"\n",(0,t.jsx)(n.p,{children:"Triggering Event: All players have joined the lobby, and the host wants to start the game."}),"\n",(0,t.jsxs)(n.p,{children:["#4 ",(0,t.jsx)(n.strong,{children:"Players enter room code"})]}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\r\n\r\nactor player\r\n\r\nplayer ->> landingPage.js: enters room code\r\n\r\nactivate landingPage.js\r\nlandingPage.js ->> backend.js: checks room code\r\nbackend.js --\x3e> landingPage.js: validates room code\r\nlandingPage.js ->> lobby.js: navigates to\r\ndeactivate landingPage.js\r\nlobby.js ->> player: player sees lobby screen\r\n\r\n"}),"\n",(0,t.jsx)(n.p,{children:"Sequence Diagram 5"}),"\n",(0,t.jsx)(n.p,{children:"Players use the room code provided by the host to enter it and join the lobby. Once entered, the landingPage.js sends the code to the backend for verification, and returns whether it's a valid code or not. If it is valid, it will navigate the user to the appropriate lobby, lobby.js. Then the user will see the lobby screen."}),"\n",(0,t.jsx)(n.p,{children:"Triggering Event: The host receives the room code and shares it with other players."}),"\n",(0,t.jsxs)(n.p,{children:["#5 ",(0,t.jsx)(n.strong,{children:"Players select avatar"})]}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\r\n\r\nactor player\r\nlandingPage.js ->> backend.js: fetch available avatars (websocket)\r\nbackend.js --\x3e> landingPage.js: return available avatars (websocket)\r\nlandingPage.js ->> player: display possible avatars\r\nplayer ->> landingPage.js: select avatar\r\nlandingPage.js ->> backend.js: update available avatars (websocket)\r\nbackend.js --\x3e> landingPage.js: confirm update (websocket)\r\nlandingPage.js ->> lobby.js: navigates to\r\nlobby.js ->> player: shows avatar in lobby screen\r\n"}),"\n",(0,t.jsx)(n.p,{children:"Sequence Diagram 6"}),"\n",(0,t.jsx)(n.p,{children:"Upon joining, each player will be presented with an array of avatars to choose from, and they must tap an avatar to join the lobby with that avatar. First, the frontend must fetch the available avatars from the backend as a websocket message. The backend returns the available avatars, and the landingPage displays them to the user for selection. The user will make a selection, and landingPage.js will update the avatar list in the backend, which will verify with a return value. Then the landingPage.js will navigate to lobby.js where the user will see the lobby along with their avatar."}),"\n",(0,t.jsx)(n.p,{children:"Triggering Event: A user has entered a valid room code."}),"\n",(0,t.jsxs)(n.p,{children:["#6 ",(0,t.jsx)(n.strong,{children:"One player is selected at random to be a drawer"})]}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\r\n\r\nactor player\r\nparticipant drawing.js\r\nparticipant lobby.js\r\nparticipant backend.js\r\n\r\nbackend.js ->> backend.js: randomly selects drawer\r\nbackend.js ->> lobby.js: start game websocket message (contains role info)\r\nlobby.js ->> drawing.js: navigates to\r\ndrawing.js ->> player: player sees drawing page\r\n"}),"\n",(0,t.jsx)(n.p,{children:"Sequence Diagram 7: showing the possibility of drawing first."}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\r\n\r\nactor player\r\nparticipant guessing.js\r\nparticipant lobby.js\r\nparticipant backend.js\r\n\r\nbackend.js ->> backend.js: randomly selects drawer\r\nbackend.js ->> lobby.js: start game websocket message (contains role info)\r\nlobby.js ->> guessing.js: navigates to\r\nguessing.js ->> player: player sees guessing page\r\n"}),"\n",(0,t.jsx)(n.p,{children:"Sequence Diagram 8: alternative showing the possibility of guessing first."}),"\n",(0,t.jsx)(n.p,{children:"Out of all players, including the host, one is randomly selected to be the first drawer. They will be shown the drawing interface. First, the backend randomly select a drawer from the list of players. Next, it will send a start game websocket message containing role info. Each player's lobby.js will take that information and either navigate them to guessing.js or drawing.js, where the users will see the appropriate UI."}),"\n",(0,t.jsx)(n.p,{children:"Triggering Event: The host pressed start game."}),"\n",(0,t.jsxs)(n.p,{children:["#7 ",(0,t.jsx)(n.strong,{children:"The drawer is given 3 random choices to choose from to draw"})]}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\r\n\r\nactor drawer\r\nparticipant drawing.js\r\nbackend.js ->> backend.js: selects 3 random prompts from list\r\nbackend.js ->> drawing.js: prompt choices (websocket)\r\ndrawing.js ->> drawer: drawer sees prompt choices\r\ndrawer ->> drawing.js: selects prompt\r\ndrawing.js ->> backend.js: current prompt (websocket)\r\n"}),"\n",(0,t.jsx)(n.p,{children:"Sequence Diagram 9"}),"\n",(0,t.jsx)(n.p,{children:"The drawer is provided with 3 random prompts on their screen as buttons to choose from to draw. They tap on the choice that they want, and then they can begin drawing. First, the backend must randomly select 3 prompts from the list of possible prompts. The backend relays these choices in a websocket message to the drawing.js frontend file. the drawer sees the list, makes a choice, and drawing.js relays the choice to the backend."}),"\n",(0,t.jsx)(n.p,{children:"Triggering Event: The drawer has been randomly selected."}),"\n",(0,t.jsxs)(n.p,{children:["#8 ",(0,t.jsx)(n.strong,{children:"Guessers see a guessing interface and drawing as it progresses"})]}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\r\n\r\nactor guesser\r\nactor drawer\r\nparticipant guessing.js\r\nparticipant drawing.js\r\nparticipant backend.js\r\n\r\ndrawer ->> drawing.js: draws on the interface\r\ndrawing.js ->> backend.js: frequent drawing information (websocket)\r\nbackend.js ->> guessing.js: frequent drawing information (websocket)\r\nguessing.js ->> guesser: guesser spectates drawing\r\nguesser ->> guessing.js: guesser makes a guess\r\nguessing.js ->> backend.js: guess information (websocket)\r\nbackend.js ->> backend.js: checks guess\r\nbackend.js --\x3e> guessing.js: guess response (websocket)\r\n"}),"\n",(0,t.jsx)(n.p,{children:"Sequence Diagram 10"}),"\n",(0,t.jsxs)(n.p,{children:["Default flow: The guessers spectate the drawing and make guesses using the AAC tablet as the round progresses.",(0,t.jsx)(n.br,{}),"\n","Alternative flow: The guessers spectate the drawing and make guesses using the keyboard after clicking the keyboard toggle button.",(0,t.jsx)(n.br,{}),"\n","There is a timer counting down during each drawing phase."]}),"\n",(0,t.jsx)(n.p,{children:"Further explanation: First, the drawer begins drawing on the interface on drawing.js, and frequent websocket information containing drawing data is sent to the backend. The drawing data is echoed to all guessing.js frontends that are spectating. Guessers spectate and enter guesses, which are relayed from guessing.js to backend.js to be checked. The user sees the result of their guess when another websocket message comes back from the backend to guessing.js."}),"\n",(0,t.jsxs)(n.p,{children:["Triggering Event: The drawer has selected one of the three random drawing prompts.",(0,t.jsx)(n.br,{}),"\n","Alternate Triggering Event: The drawer ran out of time (15s) to choose a prompt and one has been randomly selected."]}),"\n",(0,t.jsxs)(n.p,{children:["#9 ",(0,t.jsx)(n.strong,{children:"Phase ends when the timer expires or everyone has guessed correctly"})]}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\r\n\r\nactor drawer\r\nactor guesser\r\nbackend.js ->> guessing.js: guessing over (websocket)\r\nbackend.js ->> drawing.js: drawing over (websocket)\r\nguessing.js ->> guesser: reveal the prompt\r\ndrawing.js ->> drawer: show guessing phase results\r\n"}),"\n",(0,t.jsx)(n.p,{children:"Sequence Diagram 11"}),"\n",(0,t.jsx)(n.p,{children:"At this point, the correct answer will be displayed, and players will be awarded points. Point award values have not been determined yet. First, the backend messages all guessing frontends and the drawing frontend that the drawing is over along with important information about the round. Then the prompt is revealed to the guessers, and the drawer sees the results of who guessed correctly."}),"\n",(0,t.jsx)(n.p,{children:"Triggering Event: drawer draws prompt and players try to guess the drawing prompt."}),"\n",(0,t.jsxs)(n.p,{children:["#10 ",(0,t.jsx)(n.strong,{children:"Players are awarded points for guessing correctly, drawer is awarded for players guessing the drawing"})]}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\r\nactor guesser\r\nparticipant guessing.js\r\n\r\nguesser ->> guessing.js: enters guess\r\nguessing.js ->> backend.js: guess (websocket)\r\nbackend.js ->> backend.js: checks guess\r\nbackend.js ->> backend.js: adds points to guesser's score\r\nbackend.js --\x3e> guessing.js: correct guess response (websocket)\r\nguessing.js --\x3e> guesser: guesser sees they guessed correct\r\n"}),"\n",(0,t.jsx)(n.p,{children:"Sequence Diagram 12"}),"\n",(0,t.jsx)(n.p,{children:"Players will accumulate points based on their performance in the game. When a guesser enters a guess, guessing.js sends the guess in a websocket to the backend where it is checked, points are added to the players score, and the guess response data is sent back to guessing.js for the user to see."}),"\n",(0,t.jsx)(n.p,{children:"Triggering event: The drawer has begun drawing and one of the guessers wants to make a guess."}),"\n",(0,t.jsxs)(n.p,{children:["#11 ",(0,t.jsx)(n.strong,{children:"Users see summary screen"})]}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\r\n\r\nactor player\r\nparticipant summary.js\r\nparticipant backend.js\r\nbackend.js ->> backend.js: determines rankings\r\nbackend.js ->> summary.js: summary information (websocket)\r\nsummary.js ->> player: sees summary screen\r\n\r\n"}),"\n",(0,t.jsx)(n.p,{children:"Sequence Diagram 13"}),"\n",(0,t.jsx)(n.p,{children:"After everyone draws for their third time, total points will be displayed, and rankings will be shown at the end of the game. The backend will keep track of when the final round ends, and it will determine the rankings and deliver  the summary information to summary.js where users will see a summary screen."}),"\n",(0,t.jsx)(n.p,{children:"Triggering Event: All players have drawn three times."}),"\n",(0,t.jsx)(n.h2,{id:"algorithms",children:"Algorithms"}),"\n",(0,t.jsx)(n.h3,{id:"1-player-selection-random-drawer",children:"1. Player Selection (Random Drawer)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Selects one player randomly from the active lobby."}),"\n",(0,t.jsxs)(n.li,{children:["Uses ",(0,t.jsx)(n.code,{children:"Math.random()"})," to pick an index from the player list."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"2-word-selection-random-prompt-assignment",children:"2. Word Selection (Random Prompt Assignment)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Retrieves three random words from a predefined list."}),"\n",(0,t.jsx)(n.li,{children:"Uses Fisher-Yates shuffle or a similar algorithm."}),"\n",(0,t.jsx)(n.li,{children:"If no selection in 15s, a word is randomly assigned."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"3-guess-matching-algorithm",children:"3. Guess Matching Algorithm"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Converts guess and answer to lowercase, removes punctuation."}),"\n",(0,t.jsx)(n.li,{children:"Awards correct answer points"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"4-score-calculation",children:"4. Score Calculation"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Guessers earn points based on time taken."}),"\n",(0,t.jsx)(n.li,{children:"Drawer earns points based on correct guesses."}),"\n",(0,t.jsx)(n.li,{children:"Balanced scoring to avoid excessive competitiveness."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"collection-schemas",children:"Collection Schemas"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Users Collection"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\r\n  "avatar": "String",\r\n  "room_code": "String"\r\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"collection-schemas-1",children:"Collection Schemas"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Guess"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\r\n  "guess": "String",\r\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var s=r(96540);const t={},a=s.createContext(t);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);